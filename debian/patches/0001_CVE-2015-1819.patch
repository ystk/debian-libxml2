From 213f1fe0d76d30eaed6e5853057defc43e6df2c9 Mon Sep 17 00:00:00 2001
From: Daniel Veillard <veillard@redhat.com>
Date: Tue, 14 Apr 2015 17:41:48 +0800
Subject: CVE-2015-1819 Enforce the reader to run in constant memory

One of the operation on the reader could resolve entities
leading to the classic expansion issue. Make sure the
buffer used for xmlreader operation is bounded.
Introduce a new allocation type for the buffers for this effect.

v2: rebased against libxml2 (<< 2.9)
    Mike Gabriel <mike.gabriel@das-netzwerkteam.de>
--- a/include/libxml/tree.h
+++ b/include/libxml/tree.h
@@ -74,7 +74,9 @@
     XML_BUFFER_ALLOC_DOUBLEIT,	/* double each time one need to grow */
     XML_BUFFER_ALLOC_EXACT,	/* grow only to the minimal size */
     XML_BUFFER_ALLOC_IMMUTABLE, /* immutable buffer */
-    XML_BUFFER_ALLOC_IO		/* special allocation scheme used for I/O */
+    XML_BUFFER_ALLOC_IO,	/* special allocation scheme used for I/O */
+    _XML_BUFFER_ALLOC_HYBRID, 	/* DUMMY: exact up to a threshold, and doubleit thereafter */
+    XML_BUFFER_ALLOC_BOUNDED	/* limit the upper size of the buffer */
 } xmlBufferAllocationScheme;
 
 /**
--- a/tree.c
+++ b/tree.c
@@ -678,11 +678,13 @@
  * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
  * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,
  *                             improves performance
+ * XML_BUFFER_ALLOC_BOUNDED - limit the upper size of the buffer
  */
 void
 xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme) {
     if ((scheme == XML_BUFFER_ALLOC_EXACT) ||
-        (scheme == XML_BUFFER_ALLOC_DOUBLEIT))
+        (scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
+        (scheme == XML_BUFFER_ALLOC_BOUNDED))
 	xmlBufferAllocScheme = scheme;
 }
 
@@ -7099,6 +7101,19 @@
     size = buf->use + len + 100;
 #endif
 
+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+	/*
+	 * Used to provide parsing limits
+	 */
+	if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||
+	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
+	    xmlTreeErrMemory("buffer error: text too long");
+	    return(0);
+	}
+	if (size >= XML_MAX_TEXT_LENGTH)
+	    size = XML_MAX_TEXT_LENGTH;
+    }
+
     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
         size_t start_buf = buf->content - buf->contentIO;
 
@@ -7209,7 +7224,15 @@
         return(0);
 
     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);
-
+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+	/*
+	 * Used to provide parsing limits
+	 */
+	if (size >= XML_MAX_TEXT_LENGTH) {
+	    xmlTreeErrMemory("buffer error: text too long");
+	    return(0);
+	}
+    }
     /* Don't resize if we don't have to */
     if (size < buf->size)
         return 1;
@@ -7388,6 +7411,15 @@
     }
     needSize = buf->use + len + 2;
     if (needSize > buf->size){
+	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+	    /*
+	     * Used to provide parsing limits
+	     */
+	    if (needSize >= XML_MAX_TEXT_LENGTH) {
+		    xmlTreeErrMemory("buffer error: text too long");
+		    return(-1);
+	    }
+	}
         if (!xmlBufferResize(buf, needSize)){
 	    xmlTreeErrMemory("growing buffer");
             return XML_ERR_NO_MEMORY;
--- a/xmlreader.c
+++ b/xmlreader.c
@@ -2062,6 +2062,8 @@
 		"xmlNewTextReader : malloc failed\n");
 	return(NULL);
     }
+    /* no operation on a reader should require a huge buffer */
+    xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_BOUNDED);
     ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
     if (ret->sax == NULL) {
 	xmlBufferFree(ret->buffer);
@@ -3585,6 +3587,7 @@
 	    return(((xmlNsPtr) node)->href);
         case XML_ATTRIBUTE_NODE:{
 	    xmlAttrPtr attr = (xmlAttrPtr) node;
+	    const xmlChar *ret;
 
 	    if ((attr->children != NULL) &&
 	        (attr->children->type == XML_TEXT_NODE) &&
@@ -3599,8 +3602,20 @@
 		    return (NULL);
 		}
 	        reader->buffer->use = 0;
+		xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_BOUNDED);
 	        xmlNodeBufGetContent(reader->buffer, node);
-		return(reader->buffer->content);
+		if (!reader->buffer)
+		    ret = NULL;
+		else
+		    ret = reader->buffer->content;
+		if (ret == NULL) {
+		    /* error on the buffer best to reallocate */
+		    xmlBufferFree(reader->buffer);
+		    reader->buffer = xmlBufferCreateSize(100);
+		    xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_BOUNDED);
+		    ret = BAD_CAST "";
+		}
+		return(ret);
 	    }
 	    break;
 	}
@@ -4977,6 +4992,8 @@
                         "xmlTextReaderSetup : malloc failed\n");
         return (-1);
     }
+    /* no operation on a reader should require a huge buffer */
+    xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_BOUNDED);
     xmlSAXVersion(reader->sax, 2);
     reader->startElement = reader->sax->startElement;
     reader->sax->startElement = xmlTextReaderStartElement;
